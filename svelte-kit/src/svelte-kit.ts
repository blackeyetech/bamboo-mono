// imports here
import {
  bs,
  enhanceIncomingMessage,
  enhanceServerResponse,
  HttpConfig,
  RouterMatchFunc,
  WebRequest,
} from "@bs-core/shell";

import type { Adapter, Builder, Server, SSRManifest } from "@sveltejs/kit";
import type { ViteDevServer, Plugin } from "vite";

import { rollup } from "rollup";
import resolve from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";
import json from "@rollup/plugin-json";

import { writeFileSync } from "node:fs";
import * as http from "node:http";
import { pathToFileURL } from "url";

// import { WebRequest } from "@bs-core/shell";
export { bs, Router } from "@bs-core/shell";

// Misc constants here
const ADAPTER_NAME = "@bs-core/svelte-kit";
const ADAPTER_LATENCY_NAME = "svelte-kit";

const DIST_DIR = "dist";

const CONFIG = `${DIST_DIR}/config.js`;
const INDEX = `${DIST_DIR}/index.js`;
const MANIFEST = `${DIST_DIR}/server/manifest.js`;
const SERVER = `${DIST_DIR}/server/index.js`;
const CLIENT_DIR = `${DIST_DIR}/client`;

// Global vars here
let KitServer: Server;
let SsrManifest: SSRManifest;
let BasePath: string;

// Private functions here
function matcher(_: string): RouterMatchFunc {
  // This matcher function tests if a route matches an SSR route
  return (url: URL) => {
    for (const route of SsrManifest._.routes) {
      // Remove the baseUrl because Svelte SSR routing doesnt use it
      const pathname = url.pathname.slice(BasePath.length);

      if (
        route.pattern.test(pathname) ||
        url.pathname.endsWith("__data.json") // This is a svelete-kit file in memory
      ) {
        return {
          params: {},
          matchedInfo: null,
        };
      }
    }

    return false;
  };
}

async function render(webReq: WebRequest): Promise<Response> {
  // This render function calls svelte-kit to render the SSR page
  return await KitServer.respond(webReq, {
    getClientAddress: () => "",
  });
}

export const setup = async (basePath: string): Promise<void> => {
  // These files were generated by the adapter at build time
  const { manifest } = await import(pathToFileURL(MANIFEST).href);
  const serverIndex = await import(pathToFileURL(SERVER).href);

  // Set these globals so they can be used later
  BasePath = basePath;
  SsrManifest = manifest;
  KitServer = new serverIndex.Server(manifest);

  // The config.js file is generated by this adapter at build time and stores
  // the HttpConfig object past to the adapter to be used at run time
  const { httpConfig }: { httpConfig: HttpConfig } = await import(
    pathToFileURL(CONFIG).href
  );

  // Set up the HttpServer first
  const config: HttpConfig = {
    headerTimeout: 86401000, // 24 hours + 1 sec
    keepAliveTimeout: 86400000, // 24 hours
    basePath,
    ...httpConfig,
  };

  config.ssrServer = {
    adapterName: ADAPTER_LATENCY_NAME,
    render,
    matcher,
  };

  config.staticFileServer = {
    path: CLIENT_DIR, // Predefined output
    stripHtmlExt: true, // The HTML ext needs to be stripped
    immutableRegExp: [`^${CLIENT_DIR}${basePath}/_app/immutable/.*$`],
    ...httpConfig.staticFileServer,
  };
  const httpServer = await bs.addHttpServer(
    config,
    false, // NOTE: Don't start the server yet
  );

  bs.startupMsg("HTTP server has been created");

  // Init the KitServer now - it must be AFTER the HttpServer is created
  // because the server hooks will be called now and if there is a backend
  // to be initialised the HttpServer needs to be created already
  await KitServer.init({
    env: {},
  });

  // Start the http server now!
  await httpServer.start();
};

// Default function here
export default function (config: HttpConfig) {
  const adapter: Adapter = {
    name: ADAPTER_NAME,

    async adapt(builder: Builder) {
      // Get the location for a temp dir to safely store the build files in
      const out = builder.getBuildDirectory("adapter-bs-core");
      // Recreate a new temp dir
      builder.rimraf(out);
      builder.mkdirp(out);
      // Recreate a new dist dir
      // NOTE: This doesnt seem very efficient, but it is probably safer
      builder.rimraf(DIST_DIR);
      builder.mkdirp(DIST_DIR);

      // Write the static assets
      builder.writeClient(`${DIST_DIR}/client${builder.config.kit.paths.base}`);

      // Write the pre-rendered pages
      // NOTE: Write to the same directoty as the static assets since they are
      // both referenced relavtive to the base URL
      builder.writePrerendered(
        `${DIST_DIR}/client${builder.config.kit.paths.base}`,
      );

      // Write the SSR output
      builder.writeServer(out);

      // Write the manifest file for svelte
      writeFileSync(
        `${out}/manifest.js`,
        [
          `export const manifest = ${builder.generateManifest({ relativePath: "./" })};`,
          `export const prerendered = new Set(${JSON.stringify(builder.prerendered.paths)});`,
          `export const base = ${JSON.stringify(builder.config.kit.paths.base)};`,
        ].join("\n\n"),
      );

      // we bundle the Vite output so that deployments only need
      // their production dependencies. Anything in devDependencies
      // will get included in the bundled code
      // const pkg = JSON.parse(readFileSync("package.json", "utf8"));
      const bundle = await rollup({
        input: {
          index: `${out}/index.js`, // This is our svelte app rendering code
          manifest: `${out}/manifest.js`, // This is the manifest file we create above
        },
        external: [
          "@bs-core/shell", // Dont let rollup bundle this or there will be issues
          // // dependencies could have deep exports, so we need a regex
          // ...Object.keys(pkg.dependencies || {}).map(
          //   (d) => new RegExp(`^${d}(\\/.*)?$`),
          // ),
        ],
        plugins: [
          commonjs({ strictRequires: true }),
          resolve({
            preferBuiltins: true,
            // exportConditions: ["node"],
          }),
          json(),
        ],
      });

      await bundle.write({
        dir: `${DIST_DIR}/server`,
        format: "es",
        sourcemap: true,
        chunkFileNames: "chunks/[name]-[hash].js",
      });

      // This file is used by the adapter at run time to config the HttpServer
      // We are simpily stored the adapter configs for later use
      writeFileSync(
        CONFIG,
        `export const httpConfig = ${JSON.stringify(config)}`,
      );

      // This is the start up file to call to light this candle
      writeFileSync(
        INDEX,
        `import { setup } from '@bs-core/svelte-kit';\n\nawait setup("${builder.config.kit.paths.base}");`,
      );
    },
  };

  return adapter;
}

export const viteDevPlugin = (httpConfig: HttpConfig = {}): Plugin => {
  return {
    name: "bs-vite-dev-plugin",
    configureServer: async (server: ViteDevServer) => {
      // This is called when running the app in "dev" mode

      // We need the req handler from the HttpServer so lets create one
      // even though we will not actually use it directly
      const httpServer = await bs.addHttpServer(
        httpConfig,
        false, // NOTE: Don't start the server
      );

      bs.startupMsg("HTTP server has been created - but not started");

      // Add a wrapper around the req handler to the dev server's middleware
      server.middlewares.use(
        async (
          req: http.IncomingMessage,
          res: http.ServerResponse,
          next: () => void,
        ) => {
          // Enhance req/res so that the API code with work correctly
          let enhancedReq = enhanceIncomingMessage(req);
          let enhancedRes = enhanceServerResponse(res);

          // We only want the reeq handler to handle API reqs
          enhancedReq.checkSsrRoutes = false;
          enhancedReq.checkStaticFiles = false;

          // Make sure we do not generate a 404 if the route is not found
          enhancedReq.handle404 = false;

          // Call our req handler
          await httpServer.reqHandler(enhancedReq, enhancedRes);

          // If the req was handled by the req handler then we are done
          if (enhancedReq.handled) {
            return;
          }

          // If we are here the req was not handled, so call next
          next();
        },
      );
    },
  };
};
